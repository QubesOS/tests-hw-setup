#!/usr/bin/python3

import argparse
import os
import os.path
import pathlib
import struct
import sys
import fileinput
import functools
import shutil
import asyncio


class BaseGadget:
    def __init__(self, storage_path=None, cdrom=False):
        self.gadget_configfs_root = pathlib.Path("/sys/kernel/config/usb_gadget/kbd")
        self.udc = os.listdir("/sys/class/udc")[0]
        self.storage_path = storage_path
        self.storage_cdrom = cdrom

    def set_sysfs_attr(self, name, value):
        path = self.gadget_configfs_root / name
        os.makedirs(os.path.dirname(path), exist_ok=True)
        if isinstance(value, str):
            value = value.encode()
        if isinstance(value, int):
            value = str(value).encode()
        with open(path, "wb") as f:
            f.write(value)

    def create_gadget(self):
        self.set_sysfs_attr("bcdUSB", "0x0200")  # USB 2.0
        self.set_sysfs_attr("bDeviceClass", "0x00")  # specified in interface
        self.set_sysfs_attr("bDeviceSubClass", "0x00")  # specified in interface
        self.set_sysfs_attr("bcdDevice", "0x0100")  # v1.0.0
        self.set_sysfs_attr("bDeviceProtocol", "0x00")  # specified in interface
        self.set_sysfs_attr("idVendor", "0x1d6b")  # Linux Foundation
        self.set_sysfs_attr("idProduct", "0x0104")  # Multifunction composite gadget
        self.set_sysfs_attr("strings/0x409/manufacturer", "marmarek")
        self.set_sysfs_attr("strings/0x409/product", "RPi4 USB Gadget")
        self.set_sysfs_attr("strings/0x409/serialnumber", "0123456789abcdef")
        self.set_sysfs_attr("configs/c.1/bmAttributes", "0x80")  # Bus powered
        self.set_sysfs_attr("configs/c.1/MaxPower", "250")
        self.set_sysfs_attr("configs/c.1/strings/0x409/configuration", "c1")
        if self.storage_path:
            self._create_storage_function()

    def _create_storage_function(self):
        p = "functions/mass_storage.usb2/lun.0/"
        self.set_sysfs_attr(p + "cdrom", "Y" if self.storage_cdrom else "N")  # is cdrom
        self.set_sysfs_attr(p + "ro", "1")
        self.set_sysfs_attr(p + "file", self.storage_path)  # backing file
        self.set_sysfs_attr(p + "removable", "1")
        os.symlink(
            self.gadget_configfs_root / "functions/mass_storage.usb2",
            self.gadget_configfs_root / "configs/c.1/mass_storage.usb2",
        )

    def _get_gadget_dev(self, func):
        with open(self.gadget_configfs_root / (func + "/dev"), "r") as f:
            devnum = f.read()
        return "/dev/" + os.path.basename(
            os.readlink("/sys/dev/char/" + devnum.strip())
        )

    def enable(self):
        with open(self.gadget_configfs_root / "UDC", "w") as f:
            f.write(self.udc)

    def disable(self):
        with open(os.path.join(self.gadget_configfs_root, "UDC"), "w") as f:
            f.write("\n")

    def cleanup(self):
        for d in os.listdir(self.gadget_configfs_root / "configs/c.1"):
            if ".usb" in d:
                os.unlink(self.gadget_configfs_root / "configs/c.1" / d)
        for (dirpath, dirs, _files) in os.walk(
            self.gadget_configfs_root, topdown=False
        ):
            for d in dirs:
                if d in ("strings", "os_desc", "configs", "functions", "lun.0"):
                    # Linux doesn't allow to remove this one
                    continue
                os.rmdir(os.path.join(dirpath, d))
        os.rmdir(self.gadget_configfs_root)

    def __enter__(self):
        if os.path.exists(self.gadget_configfs_root):
            # previous instance didn't cleaned up
            self.disable()
            self.cleanup()
        self.create_gadget()
        self.enable()
        return self

    def __exit__(self, exc_type, exc_value, exc_traceback):
        self.disable()
        self.cleanup()


class UsbHidGadget(BaseGadget):
    def __init__(self, storage_path=None, cdrom=False):
        super().__init__(storage_path=storage_path, cdrom=cdrom)
        self.mouse_dev = None
        self.keyboard_dev = None

    def create_gadget(self):
        super().create_gadget()
        self._create_keyboard_function()
        self._create_mouse_function()

    def _create_keyboard_function(self):
        p = "functions/hid.usb0/"
        self.set_sysfs_attr(p + "protocol", "1")  # Keyboard
        self.set_sysfs_attr(p + "subclass", "1")  # boot interface subclass
        self.set_sysfs_attr(p + "report_length", "8")
        # fmt: off
        report_descriptor = [
                0x05, 0x01,     # USAGE_PAGE (Generic Desktop)
                0x09, 0x06,     # USAGE (Keyboard)
                0xa1, 0x01,     # COLLECTION (Application)
                0x05, 0x07,     #   USAGE_PAGE (Keyboard)
                0x19, 0xe0,     #   USAGE_MINIMUM (Keyboard LeftControl)
                0x29, 0xe7,     #   USAGE_MAXIMUM (Keyboard Right GUI)
                0x15, 0x00,     #   LOGICAL_MINIMUM (0)
                0x25, 0x01,     #   LOGICAL_MAXIMUM (1)
                0x75, 0x01,     #   REPORT_SIZE (1)
                0x95, 0x08,     #   REPORT_COUNT (8)
                0x81, 0x02,     #   INPUT (Data,Var,Abs)
                0x95, 0x01,     #   REPORT_COUNT (1)
                0x75, 0x08,     #   REPORT_SIZE (8)
                0x81, 0x03,     #   INPUT (Cnst,Var,Abs)
                0x95, 0x05,     #   REPORT_COUNT (5)
                0x75, 0x01,     #   REPORT_SIZE (1)
                0x05, 0x08,     #   USAGE_PAGE (LEDs)
                0x19, 0x01,     #   USAGE_MINIMUM (Num Lock)
                0x29, 0x05,     #   USAGE_MAXIMUM (Kana)
                0x91, 0x02,     #   OUTPUT (Data,Var,Abs)
                0x95, 0x01,     #   REPORT_COUNT (1)
                0x75, 0x03,     #   REPORT_SIZE (3)
                0x91, 0x03,     #   OUTPUT (Cnst,Var,Abs)
                0x95, 0x06,     #   REPORT_COUNT (6)
                0x75, 0x08,     #   REPORT_SIZE (8)
                0x15, 0x00,     #   LOGICAL_MINIMUM (0)
                0x25, 0x65,     #   LOGICAL_MAXIMUM (101)
                0x05, 0x07,     #   USAGE_PAGE (Keyboard)
                0x19, 0x00,     #   USAGE_MINIMUM (Reserved)
                0x29, 0x65,     #   USAGE_MAXIMUM (Keyboard Application)
                0x81, 0x00,     #   INPUT (Data,Ary,Abs)
                0xc0            # END_COLLECTION
        ]
        # fmt: on
        self.set_sysfs_attr(p + "report_desc", bytes(report_descriptor))
        os.symlink(
            self.gadget_configfs_root / "functions/hid.usb0",
            os.path.join(self.gadget_configfs_root, "configs/c.1/hid.usb0"),
        )

    def _create_mouse_function(self):
        p = "functions/hid.usb1/"
        self.set_sysfs_attr(p + "protocol", "0")  # tablet
        self.set_sysfs_attr(p + "subclass", "0")  # unspecified
        self.set_sysfs_attr(p + "report_length", "6")
        # fmt: off
        # this mouse reports ABSOLUTE position, not relative!
        report_descriptor = [
                0x05, 0x01,        # Usage Page (Generic Desktop Ctrls)
                0x09, 0x02,        # Usage (Mouse)
                0xA1, 0x01,        # Collection (Application)
                0x85, 0x01,        #   Report ID (1)
                0x09, 0x01,        #   Usage (Pointer)
                0xA1, 0x00,        #   Collection (Physical)
                0x05, 0x09,        #     Usage Page (Button)
                0x19, 0x01,        #     Usage Minimum (0x01)
                0x29, 0x03,        #     Usage Maximum (0x03)
                0x15, 0x00,        #     Logical Minimum (0)
                0x25, 0x01,        #     Logical Maximum (1)
                0x95, 0x03,        #     Report Count (3)
                0x75, 0x01,        #     Report Size (1)
                0x81, 0x02,        #     Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
                0x95, 0x01,        #     Report Count (1)
                0x75, 0x05,        #     Report Size (5)
                0x81, 0x03,        #     Input (Const,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
                0x05, 0x01,        #     Usage Page (Generic Desktop Ctrls)
                0x09, 0x30,        #     Usage (X)
                0x09, 0x31,        #     Usage (Y)
                0x16, 0x01, 0x80,        #     Logical Minimum (-32767)
                0x26, 0xFF, 0x7F,        #     Logical Maximum (32767)
                0x75, 0x10,        #     Report Size (16)
                0x95, 0x02,        #     Report Count (2)
                0x81, 0x06,        #     Input (Data,Var,Rel,No Wrap,Linear,Preferred State,No Null Position)
                0xC0,              #   End Collection
                0xC0,              # End Collection
                0x05, 0x0d,        # Usage Page (Digitizer)
                0x09, 0x01,        # Usage (Digitizer)
                0xA1, 0x01,        # Collection (Application)
                0x85, 0x02,        #   Report ID (2)
                0x05, 0x0d,        #   Usage Page (Digitizer)
                0x09, 0x20,        #   Usage (Stylus)
                0xA1, 0x00,        #   Collection (Physical)
                0x09, 0x32,        #     Usage (In Range)
                0x09, 0x42,        #     Usage (Tip Switch)
                0x09, 0x44,        #     Usage (Barrel Switch)
                0x15, 0x00,        #     Logical Minimum (0)
                0x25, 0x01,        #     Logical Maximum (1)
                0x95, 0x03,        #     Report Count (3)
                0x75, 0x01,        #     Report Size (1)
                0x81, 0x02,        #     Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
                0x95, 0x05,        #     Report Count (5)
                0x75, 0x01,        #     Report Size (1)
                0x81, 0x03,        #     Input (Const,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
                0x05, 0x01,        #     Usage Page (Generic Desktop Ctrls)
                0x55, 0x0E,        #     UNIT_EXPONENT (-2)       //10^(-2)
                0x65, 0x13,        #     UNIT (Inches, English Linear)  //But exponent -2, so Physical Maximum is in 10â€™s of mils.
                0x09, 0x30,        #     Usage (X)
                0x15, 0x00,        #     Logical Minimum (0)
                0x26, 0x00, 0x04,        #     Logical Maximum (1024)
                0x35, 0x00,        #     Physical Minimum (0)
                0x46, 0x00, 0x04,        #     Physical Maximum (1024)
                0x75, 0x10,        #     Report Size (16)
                0x95, 0x01,        #     Report Count (1)
                0x81, 0x02,        #     Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
                0x09, 0x31,        #     Usage (Y)
                0x26, 0x00, 0x03,        #     Logical Maximum (768)
                0x46, 0x00, 0x03,        #     Physical Maximum (768)
                0x81, 0x02,        #     Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
                0xC0,              #   End Collection
                0xC0,              # End Collection
        ]
        # fmt: on
        self.set_sysfs_attr(p + "report_desc", bytes(report_descriptor))
        os.symlink(
            self.gadget_configfs_root / "functions/hid.usb1",
            self.gadget_configfs_root / "configs/c.1/hid.usb1",
        )

    def enable(self):
        super().enable()
        self.keyboard_dev = open(
            self._get_gadget_dev("functions/hid.usb0"), "wb", buffering=0
        )
        self.mouse_dev = open(
            self._get_gadget_dev("functions/hid.usb1"), "wb", buffering=0
        )

    def disable(self):
        if self.keyboard_dev:
            self.keyboard_dev.close()
            self.keyboard_dev = None
        if self.mouse_dev:
            self.mouse_dev.close()
            self.mouse_dev = None
        super().disable()

    def write_mouse_move_report(self, x, y, wheel=0):
        # 2 - report id - stylus
        # 0x01 - in range, but not touching
        report = struct.pack("<bBhh", 2, 0x01, x, y)
        self.mouse_dev.write(report)

    def write_mouse_btn_report(self, buttons):
        # 1 - report id - buttons
        report = struct.pack("<bBxxxx", 1, buttons)
        self.mouse_dev.write(report)

    def write_keyboard_report(self, modifiers, key):
        mod_mask = 0
        for mod in modifiers:
            mod_mask |= mod
        # TODO: more keys?
        report = struct.pack("BxxBxxxx", mod_mask, key)
        self.keyboard_dev.write(report)
        self.keyboard_dev.write(b"\0" * 8)


@dataclasses.dataclass(frozen=True)
class UsbKey:
    code: int
    mods: tuple[int]


@dataclasses.dataclass(frozen=True)
class Key:
    usb: UsbKey


# based on Universal Serial Bus HID Usage Tables
keycodes = {
    # key: (mods, keycode)
    "a": Key(usb=UsbKey(code=0x04, mods=())),
    "A": Key(usb=UsbKey(code=0x04, mods=(2,))),
    "b": Key(usb=UsbKey(code=0x05, mods=())),
    "B": Key(usb=UsbKey(code=0x05, mods=(2,))),
    "c": Key(usb=UsbKey(code=0x06, mods=())),
    "C": Key(usb=UsbKey(code=0x06, mods=(2,))),
    "d": Key(usb=UsbKey(code=0x07, mods=())),
    "D": Key(usb=UsbKey(code=0x07, mods=(2,))),
    "e": Key(usb=UsbKey(code=0x08, mods=())),
    "E": Key(usb=UsbKey(code=0x08, mods=(2,))),
    "f": Key(usb=UsbKey(code=0x09, mods=())),
    "F": Key(usb=UsbKey(code=0x09, mods=(2,))),
    "g": Key(usb=UsbKey(code=0x0A, mods=())),
    "G": Key(usb=UsbKey(code=0x0A, mods=(2,))),
    "h": Key(usb=UsbKey(code=0x0B, mods=())),
    "H": Key(usb=UsbKey(code=0x0B, mods=(2,))),
    "i": Key(usb=UsbKey(code=0x0C, mods=())),
    "I": Key(usb=UsbKey(code=0x0C, mods=(2,))),
    "j": Key(usb=UsbKey(code=0x0D, mods=())),
    "J": Key(usb=UsbKey(code=0x0D, mods=(2,))),
    "k": Key(usb=UsbKey(code=0x0E, mods=())),
    "K": Key(usb=UsbKey(code=0x0E, mods=(2,))),
    "l": Key(usb=UsbKey(code=0x0F, mods=())),
    "L": Key(usb=UsbKey(code=0x0F, mods=(2,))),
    "m": Key(usb=UsbKey(code=0x10, mods=())),
    "M": Key(usb=UsbKey(code=0x10, mods=(2,))),
    "n": Key(usb=UsbKey(code=0x11, mods=())),
    "N": Key(usb=UsbKey(code=0x11, mods=(2,))),
    "o": Key(usb=UsbKey(code=0x12, mods=())),
    "O": Key(usb=UsbKey(code=0x12, mods=(2,))),
    "p": Key(usb=UsbKey(code=0x13, mods=())),
    "P": Key(usb=UsbKey(code=0x13, mods=(2,))),
    "q": Key(usb=UsbKey(code=0x14, mods=())),
    "Q": Key(usb=UsbKey(code=0x14, mods=(2,))),
    "r": Key(usb=UsbKey(code=0x15, mods=())),
    "R": Key(usb=UsbKey(code=0x15, mods=(2,))),
    "s": Key(usb=UsbKey(code=0x16, mods=())),
    "S": Key(usb=UsbKey(code=0x16, mods=(2,))),
    "t": Key(usb=UsbKey(code=0x17, mods=())),
    "T": Key(usb=UsbKey(code=0x17, mods=(2,))),
    "u": Key(usb=UsbKey(code=0x18, mods=())),
    "U": Key(usb=UsbKey(code=0x18, mods=(2,))),
    "v": Key(usb=UsbKey(code=0x19, mods=())),
    "V": Key(usb=UsbKey(code=0x19, mods=(2,))),
    "w": Key(usb=UsbKey(code=0x1A, mods=())),
    "W": Key(usb=UsbKey(code=0x1A, mods=(2,))),
    "x": Key(usb=UsbKey(code=0x1B, mods=())),
    "X": Key(usb=UsbKey(code=0x1B, mods=(2,))),
    "y": Key(usb=UsbKey(code=0x1C, mods=())),
    "Y": Key(usb=UsbKey(code=0x1C, mods=(2,))),
    "z": Key(usb=UsbKey(code=0x1D, mods=())),
    "Z": Key(usb=UsbKey(code=0x1D, mods=(2,))),
    "1": Key(usb=UsbKey(code=0x1E, mods=())),
    "!": Key(usb=UsbKey(code=0x1E, mods=(2,))),
    "2": Key(usb=UsbKey(code=0x1F, mods=())),
    "@": Key(usb=UsbKey(code=0x1F, mods=(2,))),
    "3": Key(usb=UsbKey(code=0x20, mods=())),
    "#": Key(usb=UsbKey(code=0x20, mods=(2,))),
    "4": Key(usb=UsbKey(code=0x21, mods=())),
    "$": Key(usb=UsbKey(code=0x21, mods=(2,))),
    "5": Key(usb=UsbKey(code=0x22, mods=())),
    "%": Key(usb=UsbKey(code=0x22, mods=(2,))),
    "6": Key(usb=UsbKey(code=0x23, mods=())),
    "^": Key(usb=UsbKey(code=0x23, mods=(2,))),
    "7": Key(usb=UsbKey(code=0x24, mods=())),
    "&": Key(usb=UsbKey(code=0x24, mods=(2,))),
    "8": Key(usb=UsbKey(code=0x25, mods=())),
    "*": Key(usb=UsbKey(code=0x25, mods=(2,))),
    "9": Key(usb=UsbKey(code=0x26, mods=())),
    "(": Key(usb=UsbKey(code=0x26, mods=(2,))),
    "0": Key(usb=UsbKey(code=0x27, mods=())),
    ")": Key(usb=UsbKey(code=0x27, mods=(2,))),
    "ret": Key(usb=UsbKey(code=0x28, mods=())),
    "esc": Key(usb=UsbKey(code=0x29, mods=())),
    "backspace": Key(usb=UsbKey(code=0x2A, mods=())),
    "tab": Key(usb=UsbKey(code=0x2B, mods=())),
    "space": Key(usb=UsbKey(code=0x2C, mods=())),
    "spc": Key(usb=UsbKey(code=0x2C, mods=())),
    "minus": Key(usb=UsbKey(code=0x2D, mods=())),
    "-": Key(usb=UsbKey(code=0x2D, mods=())),
    "_": Key(usb=UsbKey(code=0x2D, mods=(2,))),
    "=": Key(usb=UsbKey(code=0x2E, mods=())),
    "+": Key(usb=UsbKey(code=0x2E, mods=(2,))),
    "[": Key(usb=UsbKey(code=0x2F, mods=())),
    "{": Key(usb=UsbKey(code=0x2F, mods=(2,))),
    "]": Key(usb=UsbKey(code=0x30, mods=())),
    "}": Key(usb=UsbKey(code=0x30, mods=(2,))),
    "\\": Key(usb=UsbKey(code=0x31, mods=())),
    "|": Key(usb=UsbKey(code=0x31, mods=(2,))),
    #'#': Key(usb=UsbKey(code=0x32, mods=())),
    #'~': Key(usb=UsbKey(code=0x32, mods=(2,))),
    ";": Key(usb=UsbKey(code=0x33, mods=())),
    ":": Key(usb=UsbKey(code=0x33, mods=(2,))),
    "'": Key(usb=UsbKey(code=0x34, mods=())),
    '"': Key(usb=UsbKey(code=0x34, mods=(2,))),
    "`": Key(usb=UsbKey(code=0x35, mods=())),
    "~": Key(usb=UsbKey(code=0x35, mods=(2,))),
    ",": Key(usb=UsbKey(code=0x36, mods=())),
    "<": Key(usb=UsbKey(code=0x36, mods=(2,))),
    ".": Key(usb=UsbKey(code=0x37, mods=())),
    ">": Key(usb=UsbKey(code=0x37, mods=(2,))),
    "/": Key(usb=UsbKey(code=0x38, mods=())),
    "?": Key(usb=UsbKey(code=0x38, mods=(2,))),
    #'caps lock': Key(usb=UsbKey(code=0x39, mods=())),
    "f1": Key(usb=UsbKey(code=0x3A, mods=())),
    "f2": Key(usb=UsbKey(code=0x3B, mods=())),
    "f3": Key(usb=UsbKey(code=0x3C, mods=())),
    "f4": Key(usb=UsbKey(code=0x3D, mods=())),
    "f5": Key(usb=UsbKey(code=0x3E, mods=())),
    "f6": Key(usb=UsbKey(code=0x3F, mods=())),
    "f7": Key(usb=UsbKey(code=0x40, mods=())),
    "f8": Key(usb=UsbKey(code=0x41, mods=())),
    "f9": Key(usb=UsbKey(code=0x42, mods=())),
    "f10": Key(usb=UsbKey(code=0x43, mods=())),
    "f11": Key(usb=UsbKey(code=0x44, mods=())),
    "f12": Key(usb=UsbKey(code=0x45, mods=())),
    "printscreen": Key(usb=UsbKey(code=0x46, mods=())),
    "scroll": Key(usb=UsbKey(code=0x47, mods=())),
    "pause": Key(usb=UsbKey(code=0x48, mods=())),
    "insert": Key(usb=UsbKey(code=0x49, mods=())),
    "home": Key(usb=UsbKey(code=0x4A, mods=())),
    "pageup": Key(usb=UsbKey(code=0x4B, mods=())),
    "delete": Key(usb=UsbKey(code=0x4C, mods=())),
    "end": Key(usb=UsbKey(code=0x4D, mods=())),
    "pagedown": Key(usb=UsbKey(code=0x4E, mods=())),
    "right": Key(usb=UsbKey(code=0x4F, mods=())),
    "left": Key(usb=UsbKey(code=0x50, mods=())),
    "down": Key(usb=UsbKey(code=0x51, mods=())),
    "up": Key(usb=UsbKey(code=0x52, mods=())),
    "ctrl": Key(usb=UsbKey(code=0x0, mods=(1,))),
    "shift": Key(usb=UsbKey(code=0x0, mods=(2,))),
    "alt": Key(usb=UsbKey(code=0x0, mods=(4,))),
    "meta": Key(usb=UsbKey(code=0x0, mods=(8,))),
    "rctrl": Key(usb=UsbKey(code=0x0, mods=(16,))),
    "rshift": Key(usb=UsbKey(code=0x0, mods=(32,))),
    "ralt": Key(usb=UsbKey(code=0x0, mods=(64,))),
    "rmeta": Key(usb=UsbKey(code=0x0, mods=(128,))),
}


def parse_and_send_cmd(gadget, line):
    if line == "reconnect":
        gadget.disable()
        gadget.enable()
        return

    if line.startswith("mouse_"):
        cmd, param = line.split(" ", 1)
        if cmd == "mouse_move":
            x, y = [int(p) for p in param.split(" ")]
            # x, y = (32767/1024*x), (32767/768*y)
            gadget.write_mouse_move_report(int(x), int(y))
        elif cmd == "mouse_button":
            param = int(param)
            gadget.write_mouse_btn_report(param)
        else:
            print("Unknown command: {}".format(cmd), file=sys.stderr)
        return

    if line.startswith("type "):
        string = line[len("type ") :]
        for k in string:
            if k == " ":
                k = "space"
            parse_and_send_cmd(gadget, k)
        return

    if line.startswith("cmd "):
        string = line[len("cmd ") :]
        for k in string:
            if k == " ":
                k = "space"
            parse_and_send_cmd(gadget, k)
        parse_and_send_cmd(gadget, "ret")
        return

    key = line
    mods = []
    while True:
        if key.startswith("ctrl-"):
            mods += keycodes["ctrl"].usb.mods
            key = key[len("ctrl-") :]
        elif key.startswith("shift-"):
            mods += keycodes["shift"].usb.mods
            key = key[len("shift-") :]
        elif key.startswith("alt-"):
            mods += keycodes["alt"].usb.mods
            key = key[len("alt-") :]
        else:
            break

    if key not in keycodes:
        print("Unknown key: {}".format(key))
        return

    extra_mods, keycode = keycodes[key].usb
    mods += extra_mods
    gadget.write_keyboard_report(mods, keycode)


async def handle_client(gadget, reader, writer):
    while True:
        line = (await reader.readline()).decode("utf8")
        if not line:
            break
        try:
            parse_and_send_cmd(gadget, line.strip())
        except BrokenPipeError:
            print("failed to send '{}' - USB disconnected".format(line.strip()))
    writer.close()


async def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--storage", default=[], action="store", nargs="*")
    parser.add_argument("--is-cdrom", default=False, action="store_true")
    parser.add_argument("--storage-only", default=False, action="store_true")
    parser.add_argument(
        "--socket",
        default=None,
        action="store",
        help="Listen on this UNIX socket, instead of stdin",
    )
    parser.add_argument(
        "--socket-group",
        default=None,
        action="store",
        help="Set group owner of the socket",
    )
    args = parser.parse_args()

    storage = None
    if args.storage:
        for path in args.storage:
            if os.path.exists(path):
                storage = path
                break
        else:
            print("None of {} exist, skipping storage emulation".format(args.storage))

    gadget_class = UsbHidGadget
    if args.storage_only:
        gadget_class = BaseGadget

    with gadget_class(storage_path=storage, cdrom=args.is_cdrom) as gadget:
        if args.socket:
            server = await asyncio.start_unix_server(
                functools.partial(handle_client, gadget), args.socket
            )
            if args.socket_group:
                shutil.chown(args.socket, group=args.socket_group)
                os.chmod(args.socket, 0o660)
            async with server:
                await server.serve_forever()
        else:
            for line in fileinput.input(files=[]):
                try:
                    parse_and_send_cmd(gadget, line.strip())
                except BrokenPipeError:
                    print("failed to send '{}' - USB disconnected".format(line.strip()))


if __name__ == "__main__":
    asyncio.run(main())
